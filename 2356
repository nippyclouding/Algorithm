https://www.acmicpc.net/problem/2358
평행선

- 처음 내 제출에서는 이중 for문을 사용했다 : 시간 초과로 통과하지 못함
 private static int bizlogic(int[][] input) {
        int count = 0;
        for(int i=0; i< input.length-1; i++){
            int x = input[i][0];
            int y = input[i][1];
            for(int j=i+1; j< input.length; j++){
                int otherX = input[j][0];
                int otherY = input[j][1];
                if(x==otherX) count++;
                if(y==otherY) count++;
            }
        }
        return count;
    }


- 새로운 제출 : Map을 이용하여 같은 x 또는 y 좌표가 몇 번 등장했는지에 focus

<map 메서드 중 익숙해져야 하는 메서드>
- map.get(key) : value 조회
- map.getOrDefault(key, default) : value 조회, 존재하지 않을 경우 default값 설정
- map.keySet() : 모든 key들을 조회 // List<Integer> keys = new ArrayList<>(map.keySet());



import java.io.*;
import java.util.*;

public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());

        //x좌표가 몇 번 나왔는지를 저장하는 Map
        Map<Integer, Integer> xMap = new HashMap<>();
        //y좌표가 몇 번 나왔는지를 저장하는 Map
        Map<Integer, Integer> yMap = new HashMap<>();

        for(int i=0; i<n; i++){
            String[] inputString = br.readLine().split(" ");
            int x = Integer.parseInt(inputString[0]);
            int y = Integer.parseInt(inputString[1]);

            //xMap에 x좌표가 몇 번 나왔는지 value로 입력
            //key = x, value = 현재 map에서 x 좌표가 등장한 횟수, +1 = 현재 등장
            xMap.put(x, xMap.getOrDefault(x, 0) + 1);
            yMap.put(y, yMap.getOrDefault(y, 0) + 1);

        }

        int count = 0;

        //map.values의 리턴은 Collection

        //같은 좌표가 있을 경우 직선이 형성된다.
        for(int freq : xMap.values()) {
            if(freq >= 2) {
                count++;  
            }
        }
        for(int freq : yMap.values()) {
            if(freq >= 2) {
                count++; 
            }
        }
      
        System.out.println(count);
    }
}

- 더 효율적인 파싱

String[] inputString = br.readLine().split(" ");
int x = Integer.parseInt(inputString[0]);
int y = Integer.parseInt(inputString[1]);
- split(" ")으로 구분 시 String[] 배열 생성, 정규식을 사용하기 때문에 성능이 좋지 않다.

StringTokenizer st = new StringTokenizer(br.readLine());
int x = Integer.parseInt(st.nextToken());
int y = Integer.parseInt(st.nextToken());
- StringTokenizer로 구분 시 추가 메모리 사용 없이 단순 분할로 구분하기 때문에 성능이 좋다.
=> split 대신 StringTokenizer 사용하기




