https://www.acmicpc.net/problem/1463
백준 1463 1로 만들기 - DP 실습 문제

BFS 알고리즘을 사용해도 해결 가능
- dist 배열 생성, 1을 초기값으로 한 뒤 *2, *3, +1로 뻗어나갈 수 있다.


DP 알고리즘 동적 계획법
-	여러 하위 문제를 먼저 해결한 뒤 그 결과를 이용해 주어진 문제를 해결

-	재귀의 아이디어를 기반으로 하되, 중복되는 하위의 결과를 저장 후 재사용하는 방식
재귀 : 문제를 더 작은 하위 문재로 나누어 자기 자신을 호출, 결과를 저장하지 않기에 하위 문제를 여러 번 계산할 수 있어 비효율적이다.

DP는 중간 결과를 배열 또는 테이블에 저장
재귀 : 같은 계산을 반복하여 계산 - O(2^n)
DP : 각 하위 문제를 한 번만 계산 – O(n)

Point : 중간 결과 저장 여부

DP 해결법
1.	테이블 정의
2.	점화식 찾기
3.	초기값 정하기
이후 반복문을 이용해 배열을 채운다.



1463 문항에 적용
1. 테이블 정의 : D[i] = i를 1로 만들기 위해 필요한 연산 사용 횟수의 최솟값
2. 점화식 찾기 
D[12] = ?
- 3으로 나누거나 D[12] = D[4] + 1
- 2로 나누거나 D[12] = D[6] + 1
- 1을 빼거나 D[12] = D[11] + 1
=> D[12] = min(D[4]+1, D[6]+1, D[11]+1)
3. 초기값 정의하기 : D[1] = 0까지만 정의해도 해결된다.

<코드>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;


public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(br.readLine());

        int output = 0;
        if (N <= 3) {
            switch (N){
                case 1 : output = 0; break;
                case 2 : output = 1; break;
                case 3 : output = 1; break;
            }
        } else {
            int[] arr = new int[N + 1];
            arr[1] = 0;
            arr[2] = 1;
            arr[3] = 1;

            for (int i = 4; i < N + 1; i++) {
                if (i % 2 == 0 && i % 3 != 0) {
                    int a = arr[i / 2] + 1;
                    int b = arr[i-1] + 1;
                    arr[i] = a>b ? b : a;
                } 
                
                else if (i % 2 != 0 && i % 3 == 0) {
                    int a = arr[i / 3] + 1;
                    int b = arr[i-1] + 1;
                    arr[i] = a>b ? b : a;
                } 
                
                else if (i % 2 == 0 && i % 3 == 0) {
                    int a = (arr[i / 2] > arr[i / 3] ? arr[i / 3] : arr[i / 2]) + 1;
                    int b = arr[i-1] + 1;
                    arr[i] = a>b ? b : a;
                } 
                
                else {
                    arr[i] = arr[i - 1] + 1;
                }
            }
            output = arr[N];
        }
        System.out.println(output);
    }
}

