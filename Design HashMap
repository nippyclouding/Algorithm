https://leetcode.com/problems/design-hashmap/description/


내가 설계한 HashMap
- 10개 공간이 있는 배열을 먼저 선언
- 각 배열에는 ArrayList가 들어간다.
- ArrayList에는 크기가 2인 배열이 들어간다. (list.get(0) = 배열 1, list.get(1) = 배열 2 ...)
- 크기가 2인 배열에서 인덱스 0은 Key, 인덱스 1은 Value를 의미한다.
- 입력 키는 해싱을 거쳐 배열의 해시 인덱스 속 ArrayList에 key-value 배열로 추가된다.

import java.util.ArrayList;
import java.util.List;

public class MyHashMap {

    private final int CAPACITY = 10;
    private List<int[]>[] buckets;

    public MyHashMap() {
        buckets = new ArrayList[CAPACITY];
        for (int i = 0; i < CAPACITY; i++)
            buckets[i] = new ArrayList<>();

    }

    public void put(int key, int value) {
        int hashIndex = key % CAPACITY;
        List<int[]> list = buckets[hashIndex];

        int findIndex = -1;
        for (int i = 0; i < list.size(); i++) {
            if (list.get(i)[0] == key)          // 키 비교
                findIndex = i;     // 키의 인덱스 리턴
        }

        //key가 이미 있다면 기존의 value를 새로운 value로 update
        if (findIndex != -1) {
            list.get(findIndex)[1] = value;
            return;
        }

        //key가 없다면 key와 value를 조회하는 배열을 리스트에 삽입
        list.add(new int[]{key, value});
    }

    public int get(int key) {
        int hashIndex = key % CAPACITY;
        List<int[]> list = buckets[hashIndex];

        int findIndex = -1;
        for (int i = 0; i < list.size(); i++) {
            if (list.get(i)[0] == key)          // 키 비교
                findIndex = i;      // 키의 인덱스 리턴
        }

        if(findIndex != -1)
            return list.get(findIndex)[1];
        else return -1;

    }

    public void remove(int key) {
        int hashIndex = key % CAPACITY;
        List<int[]> list = buckets[hashIndex];

        int findIndex = -1;
        for (int i = 0; i < list.size(); i++) {
            if (list.get(i)[0] == key)          // 키 비교
                findIndex = i;      // 키의 인덱스 리턴
        }

        if(findIndex != -1) {
            list.remove(findIndex);
        }
    }
}

내가 설계한 HashMap의 문제점
- CAPACITY를 10으로 잡았다. 
=> 해시 용량(Bucket 크기)가 너무 작아 배열 속 List에 겹치는 데이터들이 많아진다 => 조회 시 성능 저하 
(겹치는 데이터가 많을 수록 O(n)으로 수렴한다.) 

- Resize 기능 구현을 하지 않았다.
리사이즈의 기능을 구현하려면 단순히 Bucket 배열의 크기를 증가시키는 것이 아닌
내부 List 데이터 속의 key들을 모두 빼내어 리사이징 후 다시 해싱을 거쳐야 한다. 
조회 성능은 향상되겠지만 리사이징 기능 자체의 성능이 매우 떨어질 것이다.

나의 해시맵 아키텍쳐 : 배열 -> 리스트 -> 배열 (3단계)
시니어님의 해시맵 아키텍쳐 : 배열 -> 노드 (2단계)

시니어님의 코드
class MyHashMap {
    private static final int SIZE = 10000;
    private Node[] buckets;

    private static class Node {
        int key, value;
        Node next;
        Node(int key, int value) {
            this.key = key;
            this.value = value;
        }
    }

    public MyHashMap() {
        buckets = new Node[SIZE];
    }

    private int getIndex(int key) {
        return key % SIZE;
    }

    public void put(int key, int value) {
        int idx = getIndex(key);
        if (buckets[idx] == null) {
            buckets[idx] = new Node(key, value);
            return;
        }

        Node curr = buckets[idx];
        Node prev = null;
        while (curr != null) {
            if (curr.key == key) {
                curr.value = value; 
                return;
            }
            prev = curr;
            curr = curr.next;
        }
        prev.next = new Node(key, value); 
    }

    public int get(int key) {
        int idx = getIndex(key);
        Node curr = buckets[idx];
        while (curr != null) {
            if (curr.key == key) {
                return curr.value;
            }
            curr = curr.next;
        }
        return -1;
    }

    public void remove(int key) {
        int idx = getIndex(key);
        Node curr = buckets[idx];
        Node prev = null;
        while (curr != null) {
            if (curr.key == key) {
                if (prev == null) {
                    buckets[idx] = curr.next; 
                } else {
                    prev.next = curr.next; 
                }
                return;
            }
            prev = curr;
            curr = curr.next;
        }
    }
}

시니어님의 해시맵 설계 중 중요하게 다룰 내용
- private static final int SIZE = 10000 : 기본적으로 크기를 1만으로 가져갔다. 내가 설정한 크기인 10보다 훨씬 크다.
- private Node[] buckets : Node 타입을 담는 배열을 선언

정적 노드 클래스 선언, 사용 
private static class Node {
        int key, value;
        Node next;
        Node(int key, int value) {
            this.key = key;
            this.value = value;
        }
}
- 내가 설계한 아키텍쳐 : 배열 - 배열리스트 - 배열
시니어님은 배열 속에 노드끼리 연결되는 연결리스트 구조를 사용했다.
배열리스트의 성능이 더 좋을 줄 알았는데, 만약 내가 key가 51인 값을 추가, 조회, 삭제한다고 가정을 하자.
먼저 해시 인덱스 1을 계산, Bucket[1]에 접근 후 Arraylist에서 key가 51인 배열을 또 찾아야 한다.(O(n)의 성능)
이렇게 되면 배열리스트의 빠른 인덱스 접근 기능을 해시맵에서 활용할 수 없다.
연결리스트로 설계하면 해시 인덱스 1을 계산, Bucket[1]에 접근 후 연결리스트에서 key가 51인 노드를 찾아야 한다.(O(n)의 성능)
조회 성능은 O(n)이지만 공간 효율성은 배열리스트보다 뛰어나서 연결리스트가 해시맵에서는 더 효율적이다.
- 아키텍쳐를 두 단계로 설계하면 리사이징 기능도 현재 내가 설계한 아키텍쳐보다 높은 성능을 가질 것이다.
