https://leetcode.com/problems/intersection-of-two-arrays/description/



                    
코딩 테스트에서 주의해야 할 점
- set1, set2 처럼 변수명을 설정한 뒤 set2를 써야 하는 부분에서 복사 붙여넣기를 한다고 set1이 들어가는 경우가 빈번하다.
- 이중 for문에서 j가 들어가야 할 공간에 i가 들어가는 경우가 빈번하다.



import java.io.*;
import java.util.*;



public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));



        int arr1Length = Integer.parseInt(br.readLine());
        int arr2Length = Integer.parseInt(br.readLine());



        int[] arr1 = new int[arr1Length];
        int[] arr2 = new int[arr2Length];



        //입력
        for(int i=0; i<arr1.length; i++){
            arr1[i] = Integer.parseInt(br.readLine());
        }
        for(int i=0; i<arr2.length; i++){
            arr2[i] = Integer.parseInt(br.readLine());
        }



        Set<Integer> set1 = new HashSet<>();
        for(int i=0; i<arr1.length; i++){
            set1.add(arr1[i]);
        }
        List<Integer> list1 = new ArrayList<>(set1);
        Set<Integer> set2 = new HashSet<>();
        for(int i=0; i<arr2.length; i++){
            set2.add(arr2[i]);
        }
        List<Integer> list2 = new ArrayList<>(set2);



        List<Integer> comparingList = list1.size()>list2.size() ? list2 : list1;
        List<Integer> comparedList = list1.size()>list2.size() ? list1 : list2;



        Set<Integer> output = new HashSet<>();
        for(int i=0; i<comparingList.size(); i++){
            int digit = comparingList.get(i);
            for(int j=0; j<comparedList.size(); j++){
                if(digit == comparedList.get(j))
                    output.add(digit);
            }
        }



        for(int i : output)
            bw.write(i + "\n");



        bw.flush();
        bw.close();



    }
}



- 현재 시간 복잡도 : o(n*2)
o(n)으로 개선할 수도 있다.
쓸데없이 set -> list, list ->set으로 전환하고 있다.
set의 기능을 제대로 활용하지 못해서 익숙한 list로 해결하려고 한다.
set의 기능을 충분히 활용하면 o(n)의 시간복잡도가 나온다.



 Set<Integer> comparingSet = set1.size()>set2.size() ? set2 : set1;
 Set<Integer> comparedSet = set1.size()>set2.size() ? set1 : set2;



 Set<Integer> output = new HashSet<>();



        for (Integer value : comparingSet) { // O(n)
            if (comparedSet.contains(value)) // O(1)
                output.add(value);
        }

