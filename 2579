https://www.acmicpc.net/problem/2579
백준 2579 계단오르기

예제 입력 
6
10 20 15 25 10 20
예제 출력 : 75

유형 : DP
1. 테이블 정의 : D[i] = i번째 계단까지 올라섰을 때의 점수 합의 최댓값
=> 위 테이블로는 현재 문제를 해결할 수 없다.

새로운 테이블 정의 : D[i][j] = i번째 계단까지 올라섰을 때의 점수 합의 최댓값, i번째 계단을 반드시 밟아야 한다.
j는 현재 연속해서 밟고 있는 계단 횟수(1 or 2) (3번 연속으로 계단을 건너뛰지 않고 밟을 수는 없다는 조건을 고려)

2. 점화식 세우기
D[k][1] : 현재까지 1개의 계단을 연속해서 밟고 k번째 계단까지 올라섰을 때의 최대 점수 합
현재까지 1개의 계단을 연속해서 밟다 = k-1번째 계단을 밟지 않았다 = k-2번째 계단을 밟았다
k-2번째 계단을 밟았을 때의 최댓값 = D[k-2][1] 이나 D[k-2][2] 중 더 큰 값

점화식 - D[k][1]
D[k][1] = max(D[k-2][1], D[k-2][2]) + arr(k)

D[k][2] : 현재까지 2개의 계단을 연속해서 밟고 k번째 계단까지 올라섰을 때의 최대 점수 합
현재까지 2개의 계단을 연속해서 밟다 = k-1번째 계단을 밟았다 = k-2번째 계단을 밟지 않았다
k-1번째 계단을 밟았을 때의 최댓값 = D[k-1][1] 
D[k-1][2]은 성립 불가능, j=2라면 k-2, k-1을 밟은 상태에서 k까지 밟기 때문

점화식 - D[k][2]
D[k][2] = D[k-1][1] + arr(k) 

3. 초기값 설정
D[1][1] = arr[1]
D[1][2] = 0 (성립 불가)
D[2][1] = arr[2]
D[2][2] = arr[1] + arr[2]

이후 반복문을 통해 배열을 채운다.



import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        int totalScore = 0;
        int[] scores = new int[n+1];
        for(int i=1; i<n+1; i++){
            scores[i] = Integer.parseInt(br.readLine());
        }

        int[][] table = new int[n+1][2];
        if(n==1){
            totalScore = scores[1];
        }
        else if(n==2){
            totalScore = scores[1] + scores[2];
        }
        else {
            table[1][0] = scores[1];
            table[1][1] = 0;
            table[2][0] = scores[2];
            table[2][1] = scores[1] + scores[2];

            for(int i=3; i<table.length; i++){
                table[i][0] = (table[i-2][0]>table[i-2][1] ? table[i-2][0] : table[i-2][1]) + scores[i];
                table[i][1] = table[i-1][0] + scores[i];
            }
            totalScore = table[n][0]>table[n][1] ? table[n][0] : table[n][1];
        }

        System.out.println(totalScore);
    }
}


예제 입력 
6
10 20 15 25 10 20
예제 출력 : 75

- 새로운 관점의 1차원 배열 풀이

1. 테이블 정의하기 - 밟지 않을 계단을 선택
N번째 계단까지의 최댓값 = 밟지 않을 계단들의 최솟값 구하기
D[i] = i번째 계단까지 올라섰을 때 밟지 않을 계단의 합의 최솟값 (i번째 계단은 반드시 밟지 않을 계단이다.)
K번째 계단을 밟지 않았다 = K-1번째 계단은 반드시 밟아야 한다.
K-2번째 계단이나, K-3번째 계단 중 하나는 반드시 밟는 계단으로 선택해야 한다.


2. 점화식 찾기
D[1] = 10, 1번째 계단을 밟지 않고, 밟지 않는 계단들의 합 최솟값
D[2] = 20, 2번째 계단을 밟지 않고, 밟지 않는 계단들의 합 최솟값
D[3] = 15, 3번째 계단을 밟지 않고, 밟지 않는 계단들의 합 최솟값

D[4] = arr[4] + D[1], 4번째 계단을 밟지 않아야 한다. (arr[4])
1, 2, 3번째 계단을 모두 연속해서 밟을 수는 없기에 1, 2번째 계단 중 가장 작은 값을 밟지 않아야 한다. (D[1])

1, 2, 3번째 계단 중 가장 작은 값을 밟지 않아야 하는데, k를 밟지 않았으면 k-1을 반드시 밟아야 하기에
3번째 계단은 고려 대상이 아니라서 1, 2번째 계단 중 작은 값만 선택한다.

D[5] = arr[5] + min(D[2, 3]) = 10 + 15 = 25
..
D[K] = arr[K] + min(D[K-2, K-3])

3. 초기값 설정
D[1] = arr[1]
D[2] = arr[2]
D[3] = arr[3]

마지막 도착 계단은 반드시 밟아야 한다.
가장 마지막으로 선택될 밟지 않을 계단은 N-1번째 계단 또는 N-2번째 계단 중 작은 값이다.
계단 최댓값 = 전체 계단의 합 - min(D[N-1, N-2))
